1：基本概念：
样本长度(sample)：样本是记录音频数据最基本的单位，常见的有8位和16位。
通道数(channel)：该参数为1表示单声道，2则是立体声。

桢(frame)：桢记录了一个声音单元，其长度为样本长度与通道数的乘积。
采样率(rate)：每秒钟采样次数，该次数是针对桢而言。
周期(period)：音频设备一次处理所需要的桢数，对于音频设备的数据访问以及音频数据的存储，都是以此为单位。

交错模式(interleaved)：是一种音频数据的记录方式，在交错模式下，数据以连续桢的形式存放，即首先记录完桢1的左声道样本和右声道样本（假设为立体声格式），再开始桢2的记录。
	而在非交错模式下，首先记录的是一个周期内所有桢的左声道样本，再记录右声道样本，数据是以连续通道的方式存储。
	不过多数情况下，我们只需要使用交错模式就可以了。

period(周期):硬件中中断间的间隔时间。它表示输入延时。
	声卡接口中有一个指针来指示声卡硬件缓存区中当前的读写位置。只要接口在运行，这个指针将循环地指向缓存区中的某个位置。
	
	frame size = sizeof(one sample) * nChannelsalsa中配置的缓存(buffer)和周期(size)大小
	在runtime中是以帧(frames)形式存储的。
	period_bytes = frames_to_bytes(runtime, runtime->period_size);
	bytes_to_frames()
2:如果想实现音频控制，可以使用ALSA实现；
	如果只是播放音频文件，高级的api如SDL， OpenAL可以实现
3：模/数（ADC）转换 ， 数/模(DAC)转换的过程
	alsa提供一些列的工具集
	alsa api：
		控制接口：管理声卡注册和请求可用设备的通用功能。
		PCM接口：管理数字音频回放(playback)和录音(capture)的接口. !!!（最常用）
		Raw MIDI接口:支持MIDI(Musical Instrument Digital Interface),标准的电子乐器。
			这些API提供对声卡上MIDI总线的访问。这个原始接口基于MIDI事件工作，由程序员负责管理协议以及时间处理。
		定时器(Timer)接口：为同步音频事件提供对声卡上时间处理硬件的访问。
		时序器(Sequencer)接口
		 混音器(Mixer)接口
4：设备命名
		 
		API库使用逻辑设备名而不是设备文件。
			设备名字可以是真实的硬件名字也可以是插件名字。
			硬件名字使用hw:i,j这样的格式。其中i是卡号，j是这块声卡上的设备号。
				第一个声音设备是hw:0,0.这个别名默认引用第一块声音设备并且在本文示例中一真会被用到。
			插件使用另外的唯一名字，比如 plughw:,表示一个插件，这个插件不提供对硬件设备的访问，而是提供像采样率转换这样的软件特性，硬件本身并不支持这样的特性。
5：声音缓存和数据传输：
		每个声卡都有一个硬件缓存区来保存记录下来的样本。
		当缓存区足够满时，声卡将产生一个中断。
		内核声卡驱动然后使用直接内存(DMA)访问通道将样本传送到内存中的应用程序缓存区。
		类似地，对于回放，任何应用程序使用DMA将自己的缓存区数据传送到声卡的硬件缓存区中。
		
		这样硬件缓存区是环缓存。
		也就是说当数据到达缓存区末尾时将重新回到缓存区的起始位置。
		ALSA维护一个指针来指向硬件缓存以及应用程序缓存区中数据操作的当前位置
		从内核外部看，我们只对应用程序的缓存区感兴趣，所以本文只讨论应用程序缓存区。
		
		应用程序缓存区的大小可以通过ALSA库函数调用来控制。
			缓存区可以很大，一次传输操作可能会导致不可接受的延迟，我们把它称为延时(latency)。
			为了解决这个问题，ALSA将缓存区拆分成一系列周期(period)(OSS/Free中叫片断fragments).
			ALSA以period为单元来传送数据。
		一个周期(period)存储一些帧(frames)。
			每一帧包含时间上一个点所抓取的样本。
			对于立体声设备，一个帧会包含两个信道上的样本。
			分解过程：
				一个缓存区分解成周期，然后是帧，然后是样本。
				左右信道信息被交替地存储在一个帧内。这称为交错 (interleaved)模式。
				在非交错模式中，一个信道的所有样本数据存储在另外一个信道的数据之后。
6：Over and Under Run

	当一个声卡活动时，数据总是连续地在硬件缓存区和应用程序缓存区间传输。
	但是也有例外。
		在录音例子中，如果应用程序读取数据不够快，循环缓存区将会被新的数据覆盖。
			这种数据的丢失被称为over run.
		在回放例子中，如果应用程序写入数据到缓存区中的速度不够快，缓存区将会"饿死"。
			这样的错误被称为"under run"。
		在ALSA文档中，有时将这两种情形统称为"XRUN"。
			适当地设计应用程序可以最小化XRUN并且可以从中恢复过来。
7：四个相关的演示代码

alsa三大硬件设备驱动模块：
	PlatForm ==》把dma buffer中的音频数据搬运到FIFO，把音频数据从FIFO中搬运到CODEX
	Codex   ==>转换成模拟信号输出到外放或者耳机中
	Mechine :指某款特定的机器
	
PCM是英文Pulse-code modulation的缩写，中文译名是脉冲编码调制。
	我们知道在现实生活中，人耳听到的声音是模拟信号，PCM就是要把声音从模拟转换成数字信号的一种技术
	
	
用alsa实现播放，用ffmpeg实现MP3，aac的转码