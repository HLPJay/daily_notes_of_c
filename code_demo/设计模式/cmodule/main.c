#include <stdio.h>
#include <stdlib.h>
#include "test_module.h"
#include "test_module_expand.h"
#include "base.h"

int main()
{
	//根据module_test 去构造  第二个参数实际上是对象实际构造函数的参数
	//会重新申请需要用的数据结构，共用一套函数方法
	void *test = New(module_test, 3);
	void *test1 = New(module_test_expand, 2);

	Show(test1);
	Delete(test);
	Delete(test1);
	return 0;
}

/**********************
	个人理解：
		C语言的这种模块开发的技巧，使C语言可以实现很多复杂的实现.
		感觉就是对要使用的数据结构和相关的函数做了一定的封装。
		那么，可以在此基础上实现C语言的单例模式，实现C语言一些复杂的设计模式（工厂模式等）
	参考网址： https://blog.csdn.net/hmsiwtv/article/details/32383887 有一系列的功能
	
	可以在此模块的基础上，进一步封装，提供只能对外访问的接口，实现单例，但是要注意释放资源。

	1：整理c的模块实现，在此基础上可以扩展单例模式，各种设计模式，用时再思考。
	2：整理线程池的逻辑。
	3：整理内存池以及字节对齐高效的原因，
	4：实现nginx的模块开发，整理nginx的模块逻辑，log模块，事件机制等
	5：TCP POLL SELECT EPOLL UDP 

为什么要设置内存对齐：
	1:拿空间换时间，各种类型，结构，计算机内存按byte划分，按照特定的规则进行数据的排布。
		有的cpu只能访问对齐后的内存，一次取4byte， 访问没有对齐的内存，计算机需要作两次访问，，而对齐只需要一次
	2:为了解决可移植行问题，对外交互时使用，
	
	1：有的cpu不支持非对齐的内存访问，支持的cpu也是通过访问对齐的内存后做拼接。
	2：底层访问内存是偏移量和不同芯片实现的，对齐cpu偏移量固定，不对齐cpu需要传递偏移量，除此之外，cache
	
	访问粒度，访问粒度越小，计算机访问同样数据频率越高，所以结构体提高cpu访问效率，按照计算机内存粒度最好
分布式锁的原理
	
	
	底层处理器的限制，有的处理器酶促访问四个字节


1：内存池的整理；
2：线程池的整理：
3：设计模式的实现
4：leetcode
**********************/